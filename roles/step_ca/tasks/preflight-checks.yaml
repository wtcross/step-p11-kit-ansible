---
- name: Verify required role variables are set
  when: vars[item] is not defined
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >
      Missing required variable: {{ item }}
  loop:
    - step_ca_name
    - step_ca_dns_names
    - step_ca_host_private_key_pkcs11_uri
    - step_ca_root_cert_local_path
    - step_ca_intermediate_cert_local_path

- name: Normalize host private key PKCS#11 URI input
  become: false
  ansible.builtin.set_fact:
    __step_ca_host_private_key_pkcs11_uri_normalized: "{{ step_ca_host_private_key_pkcs11_uri | trim }}"
  changed_when: false

- name: Validate host private key PKCS#11 URI input is not empty
  when: __step_ca_host_private_key_pkcs11_uri_normalized | length == 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >
      step_ca_host_private_key_pkcs11_uri must not be empty.

- name: Validate host private key PKCS#11 URI prefix
  when: not (__step_ca_host_private_key_pkcs11_uri_normalized | regex_search('^pkcs11:'))
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >
      step_ca_host_private_key_pkcs11_uri must start with pkcs11:.

- name: Strip PKCS#11 URI prefix for component parsing
  become: false
  ansible.builtin.set_fact:
    __step_ca_host_private_key_pkcs11_uri_body: "{{ __step_ca_host_private_key_pkcs11_uri_normalized | regex_replace('^pkcs11:', '') }}"
  changed_when: false

- name: Parse host private key PKCS#11 URI components
  become: false
  ansible.builtin.set_fact:
    __step_ca_host_pkcs11_token: "{{ (__step_ca_host_private_key_pkcs11_uri_body | regex_findall('(?:^|[;?&])token=([^;?&]+)') | first) | default('') }}"
    __step_ca_host_pkcs11_id: "{{ (__step_ca_host_private_key_pkcs11_uri_body | regex_findall('(?:^|[;?&])id=([^;?&]+)') | first) | default('') }}"
    __step_ca_host_pkcs11_module_path: "{{ (__step_ca_host_private_key_pkcs11_uri_body | regex_findall('(?:^|[;?&])module-path=([^;?&]+)') | first) | default('') }}"
    __step_ca_host_pkcs11_object: "{{ (__step_ca_host_private_key_pkcs11_uri_body | regex_findall('(?:^|[;?&])object=([^;?&]+)') | first) | default('') }}"
    __step_ca_host_pkcs11_type: "{{ (__step_ca_host_private_key_pkcs11_uri_body | regex_findall('(?:^|[;?&])type=([^;?&]+)') | first) | default('') }}"
  changed_when: false

- name: Collect missing host PKCS#11 URI components
  become: false
  ansible.builtin.set_fact:
    __step_ca_missing_host_private_key_pkcs11_uri_components: >-
      {{
        []
        + (['module-path'] if __step_ca_host_pkcs11_module_path | length == 0 else [])
        + (['token'] if __step_ca_host_pkcs11_token | length == 0 else [])
        + (['id'] if __step_ca_host_pkcs11_id | length == 0 else [])
      }}
  changed_when: false

- name: Validate required host PKCS#11 URI components
  when: __step_ca_missing_host_private_key_pkcs11_uri_components | length > 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_host_private_key_pkcs11_uri is missing required component(s):
      {{ __step_ca_missing_host_private_key_pkcs11_uri_components | join(', ') }}.
      Required components: module-path, token, id.

- name: Derive role-managed PKCS#11 URIs from host private key URI
  become: false
  ansible.builtin.set_fact:
    __step_ca_hsm_pkcs11_uri_derived: >-
      pkcs11:token={{ __step_ca_host_pkcs11_token }}?module-path={{ __step_ca_host_pkcs11_module_path }}
    __step_ca_private_key_pkcs11_uri_derived: >-
      pkcs11:token={{ __step_ca_host_pkcs11_token }};id={{ __step_ca_host_pkcs11_id }}{% if __step_ca_host_pkcs11_object | length > 0 %};object={{ __step_ca_host_pkcs11_object }}{% endif %}{% if __step_ca_host_pkcs11_type | length > 0 %};type={{ __step_ca_host_pkcs11_type }}{% endif %}?module-path={{ __step_ca_container_pkcs11_module_path }}&pin-source=file:///run/secrets/hsm-pin
    __step_ca_kms_pkcs11_uri_derived: >-
      pkcs11:token={{ __step_ca_host_pkcs11_token }}?module-path={{ __step_ca_container_pkcs11_module_path }}&pin-source=file:///run/secrets/hsm-pin
  changed_when: false

- name: Validate derived instance name
  when: _step_instance | length == 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >
      The derived instance name is empty. Set step_ca_instance explicitly.

- name: Validate DNS names input
  when: _step_ca_dns_names_csv | trim | length == 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >
      step_ca_dns_names must contain at least one DNS name.

- name: Verify certificate source files exist on the Ansible controller
  become: false
  delegate_to: localhost
  ansible.builtin.stat:
    path: "{{ item.path }}"
  register: step_ca_local_cert_stats
  loop:
    - name: root cert
      path: "{{ step_ca_root_cert_local_path }}"
    - name: intermediate cert
      path: "{{ step_ca_intermediate_cert_local_path }}"

- name: Fail when a required certificate source file does not exist
  when: not item.stat.exists
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: "Required {{ item.item.name }} file not found on Ansible controller: {{ item.item.path }}"
  loop: "{{ step_ca_local_cert_stats.results }}"

- name: Read root certificate file content
  become: false
  delegate_to: localhost
  ansible.builtin.slurp:
    src: "{{ step_ca_root_cert_local_path }}"
  register: __step_ca_root_cert_file_content

- name: Extract PEM certificates from root certificate file
  become: false
  ansible.builtin.set_fact:
    __step_ca_root_cert_pem_blocks: >-
      {{
        __step_ca_root_cert_file_content.content
        | b64decode
        | regex_findall('-----BEGIN CERTIFICATE-----[\\s\\S]*?-----END CERTIFICATE-----')
      }}
  changed_when: false

- name: Fail when root certificate file does not contain exactly one PEM certificate
  when: __step_ca_root_cert_pem_blocks | length != 1
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_root_cert_local_path ({{ step_ca_root_cert_local_path }}) must contain
      exactly one PEM certificate. Found {{ __step_ca_root_cert_pem_blocks | length }}.
      Provide only the root CA certificate in this file.

- name: Read root certificate subject and issuer
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - x509
      - -in
      - "{{ step_ca_root_cert_local_path }}"
      - -noout
      - -subject
      - -issuer
  register: __step_ca_root_cert_subject_and_issuer
  failed_when: false
  changed_when: false

- name: Fail when root certificate cannot be parsed
  when: __step_ca_root_cert_subject_and_issuer.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Failed to parse step_ca_root_cert_local_path ({{ step_ca_root_cert_local_path }})
      as an X.509 PEM certificate.
      stderr: {{ __step_ca_root_cert_subject_and_issuer.stderr | default('') | trim }}

- name: Read root certificate text for CA validation
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - x509
      - -in
      - "{{ step_ca_root_cert_local_path }}"
      - -noout
      - -text
  register: __step_ca_root_cert_text
  failed_when: false
  changed_when: false

- name: Fail when root certificate text cannot be read
  when: __step_ca_root_cert_text.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Failed to inspect step_ca_root_cert_local_path ({{ step_ca_root_cert_local_path }})
      for CA extensions.
      stderr: {{ __step_ca_root_cert_text.stderr | default('') | trim }}

- name: Fail when root certificate is not a CA certificate
  when: not (__step_ca_root_cert_text.stdout | regex_search('CA:TRUE'))
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_root_cert_local_path ({{ step_ca_root_cert_local_path }}) is not a CA
      certificate. The certificate must include Basic Constraints with CA:TRUE.

- name: Normalize root certificate subject and issuer
  become: false
  ansible.builtin.set_fact:
    __step_ca_root_cert_subject_normalized: >-
      {{
        (__step_ca_root_cert_subject_and_issuer.stdout
        | regex_findall('subject\\s*=\\s*(.+)')
        | first)
        | default('')
        | trim
      }}
    __step_ca_root_cert_issuer_normalized: >-
      {{
        (__step_ca_root_cert_subject_and_issuer.stdout
        | regex_findall('issuer\\s*=\\s*(.+)')
        | first)
        | default('')
        | trim
      }}
  changed_when: false

- name: Fail when root certificate is not self-signed
  when: __step_ca_root_cert_subject_normalized != __step_ca_root_cert_issuer_normalized
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_root_cert_local_path ({{ step_ca_root_cert_local_path }}) is not a
      self-signed root certificate.
      Subject: {{ __step_ca_root_cert_subject_normalized }}
      Issuer: {{ __step_ca_root_cert_issuer_normalized }}

- name: Read root certificate SHA256 fingerprint
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - x509
      - -in
      - "{{ step_ca_root_cert_local_path }}"
      - -noout
      - -fingerprint
      - -sha256
  register: __step_ca_root_cert_fingerprint_cmd
  failed_when: false
  changed_when: false

- name: Fail when root certificate fingerprint cannot be read
  when: __step_ca_root_cert_fingerprint_cmd.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Failed to read fingerprint from step_ca_root_cert_local_path
      ({{ step_ca_root_cert_local_path }}).
      stderr: {{ __step_ca_root_cert_fingerprint_cmd.stderr | default('') | trim }}

- name: Normalize root certificate SHA256 fingerprint
  become: false
  ansible.builtin.set_fact:
    __step_ca_root_cert_fingerprint_normalized: >-
      {{
        (__step_ca_root_cert_fingerprint_cmd.stdout
        | regex_findall('Fingerprint=(.+)')
        | first)
        | default('')
        | regex_replace(':', '')
        | trim
        | upper
      }}
  changed_when: false

- name: Fail when root certificate fingerprint is empty
  when: __step_ca_root_cert_fingerprint_normalized | length == 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Could not parse a SHA256 fingerprint from step_ca_root_cert_local_path
      ({{ step_ca_root_cert_local_path }}).

- name: Read intermediate certificate file content
  become: false
  delegate_to: localhost
  ansible.builtin.slurp:
    src: "{{ step_ca_intermediate_cert_local_path }}"
  register: __step_ca_intermediate_cert_file_content

- name: Extract PEM certificates from intermediate certificate bundle
  become: false
  ansible.builtin.set_fact:
    __step_ca_intermediate_cert_pem_blocks: >-
      {{
        __step_ca_intermediate_cert_file_content.content
        | b64decode
        | regex_findall('-----BEGIN CERTIFICATE-----[\\s\\S]*?-----END CERTIFICATE-----')
      }}
  changed_when: false

- name: Fail when intermediate certificate bundle does not contain any PEM certificates
  when: __step_ca_intermediate_cert_pem_blocks | length == 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_intermediate_cert_local_path ({{ step_ca_intermediate_cert_local_path }})
      must contain at least one PEM certificate to form a chain.

- name: Verify each intermediate bundle certificate chains to the configured root certificate
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - verify
      - -CAfile
      - "{{ step_ca_root_cert_local_path }}"
      - -untrusted
      - "{{ step_ca_intermediate_cert_local_path }}"
    stdin: "{{ item }}"
  register: __step_ca_intermediate_chain_verify_results
  failed_when: false
  changed_when: false
  loop: "{{ __step_ca_intermediate_cert_pem_blocks }}"

- name: Fail when an intermediate bundle certificate does not chain to the configured root certificate
  when: item.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_intermediate_cert_local_path ({{ step_ca_intermediate_cert_local_path }})
      contains a certificate that does not chain to step_ca_root_cert_local_path
      ({{ step_ca_root_cert_local_path }}).
      Certificate position in bundle: {{ __step_ca_intermediate_verify_result_index + 1 }}.
      openssl verify stderr: {{ item.stderr | default('') | trim }}
      openssl verify stdout: {{ item.stdout | default('') | trim }}
  loop: "{{ __step_ca_intermediate_chain_verify_results.results }}"
  loop_control:
    index_var: __step_ca_intermediate_verify_result_index

- name: Read SHA256 fingerprints for intermediate bundle certificates
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - x509
      - -noout
      - -fingerprint
      - -sha256
    stdin: "{{ item }}"
  register: __step_ca_intermediate_cert_fingerprint_results
  failed_when: false
  changed_when: false
  loop: "{{ __step_ca_intermediate_cert_pem_blocks }}"

- name: Fail when an intermediate bundle certificate fingerprint cannot be read
  when: item.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Failed to read SHA256 fingerprint for a certificate in
      step_ca_intermediate_cert_local_path ({{ step_ca_intermediate_cert_local_path }}).
      Certificate position in bundle: {{ __step_ca_intermediate_fingerprint_result_index + 1 }}.
      stderr: {{ item.stderr | default('') | trim }}
  loop: "{{ __step_ca_intermediate_cert_fingerprint_results.results }}"
  loop_control:
    index_var: __step_ca_intermediate_fingerprint_result_index

- name: Normalize intermediate bundle certificate SHA256 fingerprints
  become: false
  ansible.builtin.set_fact:
    __step_ca_intermediate_cert_fingerprints_normalized: >-
      {{
        __step_ca_intermediate_cert_fingerprint_results.results
        | map(attribute='stdout')
        | map('regex_replace', '^.*Fingerprint=', '')
        | map('regex_replace', ':', '')
        | map('trim')
        | map('upper')
        | list
      }}
  changed_when: false

- name: Fail when intermediate certificate bundle contains the root certificate
  when: __step_ca_root_cert_fingerprint_normalized in __step_ca_intermediate_cert_fingerprints_normalized
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_intermediate_cert_local_path ({{ step_ca_intermediate_cert_local_path }})
      must not include the root certificate from step_ca_root_cert_local_path
      ({{ step_ca_root_cert_local_path }}). Remove the root certificate from the
      intermediate bundle.

- name: Normalize expected DNS names for SAN validation
  become: false
  ansible.builtin.set_fact:
    __step_ca_expected_dns_names_normalized: >-
      {{
        _step_ca_dns_names_csv
        | split(',')
        | map('trim')
        | reject('equalto', '')
        | map('lower')
        | unique
        | list
      }}
  changed_when: false

- name: Read intermediate certificate SAN extension
  become: false
  delegate_to: localhost
  ansible.builtin.command:
    argv:
      - openssl
      - x509
      - -in
      - "{{ step_ca_intermediate_cert_local_path }}"
      - -noout
      - -ext
      - subjectAltName
  register: __step_ca_intermediate_cert_san
  failed_when: false
  changed_when: false

- name: Fail when intermediate certificate SAN extension cannot be read
  when: __step_ca_intermediate_cert_san.rc != 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      Failed to read subjectAltName extension from intermediate certificate
      {{ step_ca_intermediate_cert_local_path }}.
      stderr: {{ __step_ca_intermediate_cert_san.stderr | default('') | trim }}

- name: Parse DNS SAN entries from intermediate certificate
  become: false
  ansible.builtin.set_fact:
    __step_ca_intermediate_dns_sans_normalized: >-
      {{
        __step_ca_intermediate_cert_san.stdout
        | regex_findall('DNS:([^,\\s]+)')
        | map('trim')
        | reject('equalto', '')
        | map('lower')
        | unique
        | list
      }}
  changed_when: false

- name: Determine DNS names missing from intermediate certificate SAN
  become: false
  ansible.builtin.set_fact:
    __step_ca_missing_dns_names_in_intermediate_san: >-
      {{
        __step_ca_expected_dns_names_normalized
        | difference(__step_ca_intermediate_dns_sans_normalized)
      }}
  changed_when: false

- name: Fail when intermediate certificate SAN does not cover configured DNS names
  when: __step_ca_missing_dns_names_in_intermediate_san | length > 0
  become: false
  delegate_to: localhost
  ansible.builtin.fail:
    msg: >-
      step_ca_intermediate_cert_local_path ({{ step_ca_intermediate_cert_local_path }})
      is missing required DNS SAN entries for step_ca_dns_names.
      Missing: {{ __step_ca_missing_dns_names_in_intermediate_san | join(', ') }}.
      Expected: {{ __step_ca_expected_dns_names_normalized | join(', ') }}.
      Certificate DNS SANs: {{ __step_ca_intermediate_dns_sans_normalized | join(', ') }}.
